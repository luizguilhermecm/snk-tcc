% vim: set ai tw=80 fileencoding=utf8: 
%-------------------------------------------------------------------------------
\chapter{Introdução}

Diante da  dificuldade de se melhorar processadores \textit{single-core} devido 
ao alto consumo de energia e as altas temperaturas, a indústria de processadores 
adotou como solução a esses problemas, o desenvolvimento de processadores 
\textit{multi-core}, ou seja, processadores com mais de um núcleo \cite{aapc}. 
Além disso também considerou-se o poder de processamento 
quando se utilizam vários processadores \textit{single-core} trabalhando 
simultaneamente, os quais oferecem grande desempenho, maior eficiência energética 
e menor custo.
Porém, as aplicações desenvolvidas para a arquitetura \textit{single-core} não 
se utilizam do poder computacional dos processadores \textit{multi-core}.
Para que as aplicações possam usufruir do alto desempenho que estes processadores 
oferecem, as aplicações devem ser divididas em múltiplas partes para que possam 
ser executadas em paralelo.

A paralelização de código permite ao programador resolver problemas com maior 
eficiência, porém projetar e codificar um programa paralelo continua sendo uma 
tarefa difícil, uma vez que além de dividi-lo em pequenas tarefas, deve-se 
considerar a concorrência entre elas, as dependências de dados, entre outros 
fatores que dificultam o trabalho de paralelização \cite{aipp}.

Programas computacionalmente custosos, em geral gastam a maior parte do esforço 
na execução de ,\textit{loops}, declarações de iteração que permitem que
declarações sejam executadas repetidamente, assim, a maior parte do ganho de 
eficiência será obtido otimizando as partes do software onde há maior esforço 
computacional.
As técnicas de reestruturação de \textit{loops} como \textit{loop 
fusion, loop fission, loop peeling}, entre outras, podem ser utilizadas para
otimizar \textit{loops} e obter ganho de eficiência, melhorar o 
\textit{data locality}\footnote{A
        memória \textit{cache} assume que se um dado é acessado uma vez este 
        poderá ser acessado novamente em breve, esse comportamento é denominado 
        \textit{data locality}, podendo ser de dois tipos:
        \textit{temporal locality}, se o
        dado é reusado e \textit{spatial locality}, se o programa pode utilizar
        os dados próximos ao dado recém acessado, estes são também carregados
        na memória \textit{cache}.
}
e até o consumo energético pode ser diminuído \cite{Liu:2004}.

Neste contexto o objetivo deste trabalho será obter ganho de eficiência através da 
utilização de técnicas de reestruturação de \textit{loops} e de dependências de 
dados aplicados a um software de equalização de áudio.

O restante deste trabalho está dividido da seguinte forma: O capítulo 2
  apresenta os trabalhos relacionados; O capítulo 3
  apresenta a fundamentação teória de arquiteturas paralelas, dependência de
  dados e das técnicas de transformações de \textit{loops}; O capítulo 4 é  
  apresentado os resultados experimentais; O capítulo 5 é apresentada a 
  conclusão sobre o trabalho.
