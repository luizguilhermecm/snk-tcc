% vim: set ai tw=80 fileencoding=utf8: 
%-------------------------------------------------------------------------------
\section{Dependência de Dados}

Em dependência de dados deve-se garantir que um dado seja produzido e consumido
na ordem correta, assim, cuidando para que não se intercale o \textit{load} e o
\textit{store} em um mesmo local da memória, desta forma, o próximo
\textit{load} pode obter um valor errado. 
Da mesma forma, dois \textit{stores} devem ocorrer na ordem correta para 
que no próximo \textit{load} seja obtido o valor correto.
Assim, dependência de dados pode ser definida como:

\begin{verbatim}
Definição 1: Existe dependência de dados da declaração $S_1$ para a declaração 
$S_2$ (declaração $S_2$ depende da declaração $S_1$) se e somente se:
        1 -> Ambas as declarações acessem o mesmo local de memória e ao menos
        umas delas realizará \textit{store} na memória, e
        2 -> Existe um caminho de execução viável de $S_1$ para $S_2$.
\end{verbatim}

Neste capítulo serão apresentadas várias propriedades onde as dependências 
podem ser classificadas.


\subsection{Classificação de \textit{Load-Store}}

Em termos da ordem de \textit{load-store}, as dependências podem ocorrer de 
três formas em um programa:

\begin{alineas}
        \item \textit{True dependence.} Onde uma declaração realiza 
        \textit{store} em um local da memória em que será realizado um 
        \textit{load} por uma segunda declaração.
        \begin{verbatim}
        S1    x = ...
        S2    ... = x
        \end{verbatim}
        A dependência garante que $S_2$ irá ler exatamente o que foi computado
        por $S_1$. Esse tipo de dependência é também conhecida por dependência 
        de fluxo e é denotada por $S_1 \delta S_2$ (lê-se, $S_2$ depende 
        de $S_1$).
        \item \textit{Antidependence.} Uma primeira declaração realiza
        \textit{load} de um local onde uma segunda declaração irá escrever.
        \begin{verbatim}
        S1    ... = x
        S2    x = ...
        \end{verbatim}
        Esta dependência previne a troca na ordem de execução entre $S_1$ 
        e $S_2$, tal qual poderia resultar em $S_1$ utilizando-se do valor 
        computado por $S_2$. 
        Em essência essa dependência existe para prevenir uma transformação que 
        introduziria uma nova dependência do tipo \textit{true dependence} que 
        de fato não existe no programa original. 
        \textit{Antidependence} é denotado $S_1 \delta^- S_2$ 
        ou $S_1 \delta^{-1} S_2$.

        \item \textit{Output dependence.} Ocorre quando duas declaração 
        realizam \textit{store} em um mesmo local.
        \begin{verbatim}
        S1    x = ...
        S2    x = ...
        \end{verbatim}
        Essa dependência previne que ocorra uma troca entre as declarações e 
        faça com que uma declaração que irá realizar \textit{load} do valor 
        computado não leia o valor errado.
        \begin{verbatim}
        S1    x = 1
        S2    ...
        S3    x = 2 
        S4    y = 2 * x
        \end{verbatim}
        \textit{Output dependence} é denotado $S_1 \delta^0 S_2$.
\end{alineas}

%-------------------------------------------------------------------------------
\subsection{Dependência em Loops}

Extendendo o conceito de dependência para \textit{loops} requer de alguma forma 
parametrizar as declarações pelas iterações do \textit{loop} que são
executadas.
Para um simples \textit{loop}:

\begin{verbatim}
        for(int i = 1; i < N; i++)
S1          a[i+1] = a[i] + b[i]
\end{verbatim}

A declaração $S_1$ em qualquer iteração do \textit{loop} depende dela mesmo da
iteração anterior. Embora uma simples alteração no \textit{index} do vetor pode
fazer com que a declaração tenha dependência de duas iterações anteriores.

\begin{verbatim}
        for(int i = 1; i < N; i++)
S1          a[i+2] = a[i] + b[i]
\end{verbatim}

Para melhor definir dependências em \textit{loops},  pode se fazer necessário o
uso de alguma forma de parametrização das declarações, para que através desta
representação seja possível identificar em qual iteração as declarações ocorrem.
Para isso faz-se necessário o uso de números inteiros auxiliares (ou um vetor de
números inteiros) os quais irão representar o número da iteração de cada 
\textit{loop} onde as declaração estão aninhadas.
Para um \textit{loop} simples

\begin{verbatim}
        for(int i = 1; i < N; i++)
            ...
\end{verbatim}

o número da iteração é igual ao número do \textit{loop index}, neste caso o $i$.
O \textit{index} inicia em 1 na primeira iteração, assumindo o valor 2 na
segunda iteração e assim por diante.

Considerando um \textit{loop} parametrizado

\begin{verbatim}
        for(int i = L; i < U; i = i + S)
            ...
\end{verbatim}

o número da iteração será 1 quando $i$ é for a $L$, será 2 quando $i$ for
igual a $L+S$ e assim em diante. 
Formalizando-se o conceito de parametrização;

\begin{verbatim}
        Definição 2: Para um loop arbitrário em que o index I do loop é
        incrementado de L até U em incrementos de S, o número da iteração
        (normalizado) i de uma iteração qualquer terá o valor de 
        (I - L + 1)/ S, onde I é o valor do index daquela iteração.
\end{verbatim}

No caso de \textit{loops} aninhados, o nível de aninhamento de um determinado 
\textit{loop} será igual ao número de \textit{loops} que estão iterando sobre
ele somado de um. Em aninhamento de \textit{loops} os mesmo serão enumerados do
mais externo para o mais interno, começando em 1. Formalizando-se este conceito
tem-se;

\begin{verbatim}
        Definição 3: Para um aninhamento de n loops, o vetor de iteração i de
        uma determinada iteração no loop mais interno é um vetor de inteiros que
        contém o número da iteração de cada loop na ordem do aninhamento. O
        vetor de iterações é dado pela seguinte equação
                $i = {i_1, i_2, ..., i_n}$
        onde i_k, 1 <= k <= n, representa o número da iteração do k-ésimo loop
        aninhado.
\end{verbatim}

Considerando-se um aninhamento de dois \textit{loops} e o vetor de iteração
$it\_array[2]$, onde $it\_array[0]$ contém o número da iteração do \textit{loop}
mais externo e $it\_array[1]$ do loop mais interno. 
O conjunto de todas as possibilidades do vetor de iteração é chamado de espaço 
de iteração (\textit{iteration space}). 
O espaço de iteração para este aninhamento seria $\{(1,1),(1,2),(2,1),(2,2)\}$.

Devido a importância da ordem de execução para tratamento de dependência,
vetor de iteração precisam ser precisos quanto a ordem dos seus elementos
internos em relação a ordem de aninhamento dos \textit{loops}. 










%referencia: ocfma
%-------------------------------------------------------------------------------
